# Kitty's Omakase
COS 426 Final Project
Maxwell Lin (ml7013), Emily Luo (el5267), Jadi Wang (jw8102)
To play our game, click this [link](https://jadi1.github.io/kitty-omakase/).

## Introduction
Our group wanted to create a game where the player runs a restaurant modeled after the indie video game “Overcooked”. In this restaurant, the player prepares sushi by converting ingredients, like tuna and nori, into dishes. The player is expected to fulfill orders, which are randomly generated by the game. Our main character is inspired by Jadi’s former cat, FatFat, and thus we title our game “Kitty’s Omakase.”

## Methodology
### I. Main GameScene and Items
The top of the object hierarchy is the game scene, which is a ThreeJS scene object which holds the player, a grid of furniture objects, and a grid of items. These grids are stored as 2D arrays, meaning that furniture and item positions are discretized. The layout of the kitchen is determined on load by a 2D char array—we did this so that it would be easy to modify the initial item and furniture layout while testing. The array is iterated through and the corresponding objects instantiated and placed in the game scene grids. We chose to snap objects and furniture to the grid so that interaction checks would be easy to look up—an alternative would allow fully continuous movement for all objects and obstacles, but it would be more difficult to handle interactions. In the end we settled on a middle ground in which the player may move continuously around the kitchen, but interactions would be snapped to a grid point. 

Much of the functionality of items is located in the parent class Item (extending ThreeJS Group). We store the item’s row, column, whether it is held, and what object is holding it. Items share several functions which deal with common operations like grabbing, dropping, trashing, and deleting. Finally we have an update function which updates the visual position of the object in the scene based on the state of the object fields. If the object is on a table, it must have a higher y-position than if it were on the floor. If it is being held, it must follow the object holding it. 

The items are further split into two categories: food items (salmon, nori, etc.) and containers (pots and plates). We have a class for food items as a lot of the functionality is repeated between the ingredients, such as an isPrepared flag. If trashed, it must remove itself from the object holding it if such an object exists. For pots and plates, they must be able to receive food items and store them internally. They also interact differently with the trash, as pots and plates should trash the food they contain but not themselves. We modeled all the food items ourselves in Blender. 

Likewise, furniture items have a parent class KitchenFurniture (also extending Group). This class stores row, column, and an interact function that gets overloaded by the specific furniture instances. Ingredient bins return an ingredient to the player when interacted. The cutting board turns fish items on the board into their prepared versions. The delivery station, trash, and stove all have unique interactions when the player attempts to drop a specific item on them. For the furniture item meshes, we downloaded an open-source Overcooked kitchen assets file from Sketchfab that contained a lot of the items. We then split the mesh in Blender so that each furniture item could be exported and used as its own mesh, and added our own food item images on top of the default ingredient bins. 

### II. Interaction Logic
We chose to place most of the logic involving grabs, drops, and interactions into the player class called ToonCat (also downloaded on Sketchfab—that’s what the mesh was named when we downloaded it, and it stuck). The game scene handles the event listeners, and passes it down into the player if applicable. If it triggers a pickup, the player checks to see if its target cell contains an item and picks it up. If the target cell contains an ingredient bin, it spawns a new ingredient of that type and sets it to be held by the player. If a drop is triggered, we first check to see if the target cell contains any furniture with special logic. The delivery station will check to see if the item being held satisfies an order, then removes it from the player, while the trash will remove food items. Then, we check to see if the target cell contains an item. Depending on the target item and what item the player is currently holding, we may choose to combine them together. For example, a pot and unprepared rice will stack together, and prepared ingredients will stack together and on plates. Finally, the cat also has a walking animation that plays when a movement key is pressed.

### III. Cooking Logic
We have three ingredients that need to be “prepared” in some way before combining them into different dishes: rice, salmon, and tuna. Rice must be cooked in a pot to completion first, and fish must be chopped on the cutting board table. Once a food is done preparing, it turns into a “PreparedFood” object. The class PreparedFood contains all the foods/meshes that are already in a “prepared” state (e.g. when fish is finished chopping, it turns into a PreparedFood object). We implemented progress bars using planeGeometry to visualize the preparation time for both rice cooking and fish chopping. Only properly “prepared” items can go on a plate; unprepared items will not work. 
A significant portion of the game requires being able to combine different prepared food items in different ways–for example in order to make the final tuna sushi, you can either combine tuna + nori/rice, nori + tuna/rice, or rice + tuna/nori. This logic is all handled within the PreparedFood class, which stores all the varying ways two food items can be validly combined, and switches out the mesh accordingly. 

### IV. Game Logic
One of key components of the original Overcooked game is fulfilling orders within a certain time frame. We reimplemented a simple version of the order system with two menu items: tuna sushi and salmon sushi. The list of orders is a flat UI overlaid on the camera scene, and up to two orders may exist at any time. Each specific order card is its own component that can be pushed or removed from the DOM depending on if it has been completed. The recipes on the cards are selected from the list of valid order combinations, which in our case is only two. 
To deliver an order, the user must have the completed food item on the plate, and then drop it into the delivery station. In order to verify that an order is correct, we check the food item that is on the plate’s name, and if that name matches a menu item name that is currently in the active orders list, we mark it as completed and remove that order from the order list.

Correctly delivered orders (tuna sushi and salmon sushi) result in +50 points for the player. All other combinations of food on a plate result in an incorrect delivery, which is -30 points for the player. Points are clipped so that they do not go below 0. Each game level lasts three minutes each run, with a countdown timer displayed at the bottom of the screen. At the end of the game run time, your final score will be displayed, with the option to restart the game or return to the main menu screen.

For better game quality of life, we added a welcome screen that displays “start game” and “rules” buttons upon initial loading of our game site. Once in the main game scene, we implemented a pausing feature that can be triggered via the Escape key or pressing the pause button on the screen. When paused, it pauses all game operations (player movement, countdown timer) and displays a menu with the options to resume, view the rules again, or exit the game. We’ve also added thematic music to play during the game, with an option to mute.

## Results
A video demo of our project can be found at this YouTube link. Regarding ethical concerns, we believe that our game contributes to human society and well being, avoids harm, is honest and trustworthy, is fair and doesn’t discriminate, and respects privacy. We do recognize that our game takes significant inspiration from an existing work, and attribute many of our ideas and mechanics to Overcooked. We understand that under more professional circumstances this could be distasteful if not infringement. However, in the fairly casual context surrounding this final project, we find that our personal interpretation of the game is acceptable, given that we rebuilt all the technical mechanics from scratch and credit any assets used in the process. 

## Next Steps
There are a couple features we could have added to this project given more time. For one, a level system with unique recipes and kitchens much like the original Overcooked would have been a great way to extend the gameplay loop and replayability. Another possible feature would be a form of multiplayer, either online or local (WASD and arrow keys separately). General touch ups on visuals, such as more animations during item interactions, would have also been a welcome addition.

## Contribution Breakdown
Emily Luo: Separated furniture meshes in blender, built most of the UI components (order list, welcome screen, pausing screen, music), and handled the food delivery logic 
Jadi Wang: Implemented cooking and food combination logic, modeled the different ingredients and food items in Blender.
Maxwell Lin: Built initial movement logic, designed gameScene internal structure, implemented functionality for trash, misc. bug fixes and quality of life tweaks.

## References
https://ghosttowngames.com/game/overcooked/

### Online Assets Used:
Kitchen Furniture: https://sketchfab.com/3d-models/overcooked-kitchen-assets-fan-art-ec99c64c346347a89454f569054ddb86 
Toon Cat: https://skfb.ly/6TKrP 
Music: https://www.youtube.com/watch?v=7PvYu-1iEbY


## License
[MIT](./LICENSE)
